"use strict";
var TapServiceConnector = (function() {
    function TapServiceConnector(_serviceUrl, _schema, _shortname){
        this.tapService = new TapService(_serviceUrl, _schema, _shortname, true)
        
        this.jsonLoad = undefined;

        this.testforConstrain = false;
        this.json = {};

        this.tabContaninBtnRemoveConstraint = [];
        this.testApiRooQuery = false;
        this.table = []

        this.objectMapWithAllDescription = {"root_table": {"name": "root_table_name", "schema": "schema", "columns":[]}, "tables": {}, "map": {"handler_attributs": {}}}
        this.jsonContaintJoinTable = {Succes:{status: "", base_table: "", joined_tables: []}, Failure: {NotConnected: {status: "", message: ""}, WrongTable: {status: "", message: ""}}}
        this.connector = {status: "", message: "", service: {}, votable: ""}
        this.jsonAdqlContent = {'rootQuery': "", "constraint": {}, 'allJoin': {}, 'allCondition': {}, "status": {"status": "Not Built", 'orderErros': ""}}
        this.api ="";
        this.attributsHandler = new HandlerAttributs();
        this.jsonCorrectTableColumnDescription = {"addAllColumn": {}};
        this.setAdqlConnectorQuery = function (correctTableNameFormat) {
            let query = "SELECT TOP 5 * FROM " + correctTableNameFormat;
            return query
        }
    }

    /**
    * return the full json created by the method createJson()
    */
    TapServiceConnector.prototype.loadJson = function () {
        if(this.jsonLoad === undefined){
            this.jsonLoad = this.tapService.createJson();
        }
        return this.jsonLoad;
    }

    TapServiceConnector.prototype.getFields=function (votableQueryResult,url){
        let contentText = votableQueryResult.responseText;
        let rootFields = [];
        if ( url === "http://simbad.u-strasbg.fr/simbad/sim-tap/sync" ||  url === "http://dc.zah.uni-heidelberg.de/tap/sync") {

            rootFields = VOTableTools.getField(votableQueryResult);
        } else {
            rootFields = VOTableTools.genererField(votableQueryResult, contentText);
        }

        return rootFields;
    }

    /**
    *
    * @param {*} root  represent the root table
    * @param {*} json represent the main json create by the method createMainJson
    * @returns return the list of id of join table
    */
    TapServiceConnector.prototype.joinAndId = function (root, json) {
        var list = [];
        for (var key in json) {
            if (key == root) {
                for (var join in json[key].join_tables) {
                    list.push(json[key].join_tables[join].target);
                    list.push(join);
                }
            }
        }
        return list;
    }

    /**
     *
     * @param {*} listJoinAndId the list of id returned by TapServiceConnector.prototype.getListJoinAndId
     * @return   list of all id
     */

    TapServiceConnector.prototype.getListeId = function (listJoinAndId) {
        var listId = [];
        for (var i = 0; i < listJoinAndId.length; i = i + 2) {
            if (!json2Requete.isString(listJoinAndId[i])) {
                var temp = listJoinAndId[i][0];
            } else {
                var temp = listJoinAndId[i];
            }
            if (listId.indexOf(temp) == -1) {
                listId.push(temp);//record the key linked to root table, No repeating
            }
        }
        return listId;
    }

    /**
     *
     * @param {*} rootName |the root table names of tabservice
     * @param {*} mainJsonData the main json generated by the  method createJson()
     * @returns return array containing all join table with correct id
     */
    TapServiceConnector.prototype.getListJoinAndId = function (rootName, mainJsonData) {
        var listJoinAndId = [];
        listJoinAndId = this.joinAndId(rootName, mainJsonData)
        return listJoinAndId;
    }

    /**
     *
     * @param {*} baseTableName  the root table name
     * @returns return all join table of the root table name
     */
    TapServiceConnector.prototype.getJoinTables = function (baseTableName) {
        var data = this.loadJson();
        var jsonread = new jsonRead(data);
        return jsonread.joinTable(baseTableName);
    }

    TapServiceConnector.prototype.getDataTable=function (votableQueryResult){
        return  VOTableTools.votable2Rows(votableQueryResult);
    }
    
    TapServiceConnector.prototype.getObjectMapAndConstraints = function () {
        let api = this.api;
        let rootTable = api.getConnector().service["table"];
        let jsonWithaoutDescription = this.loadJson();
        let jsonAdqlContent = api.tapServiceConnector.jsonAdqlContent;
        this.objectMapWithAllDescription.root_table.name = rootTable;
        this.schema = api.getConnector().service["schema"];
        this.objectMapWithAllDescription.root_table.schema = this.schema;
        this.objectMapWithAllDescription.root_table.columns =  api.tapServiceConnector.objectMapWithAllDescription.map['handler_attributs'];
        let correctCondition;
        let formatJoinTable = "";
        let correctJoinFormaTable = "";
        let correctWhereClose = "";
        
        let testMap = false;
        let map = {};
        if (testMap == false) {
            map = this.getObjectMapAndConstraint(jsonWithaoutDescription, rootTable);
        }

        let allJoinRootTable = this.createAllJoinTable(map)
        let allTables = allJoinRootTable;
        for (let k = 0; k < allTables.length; k++) {
            for (let tableKey in jsonWithaoutDescription) {
                if (tableKey == allTables[k] || this.schema + "." + tableKey == allTables[k]) {
                    formatJoinTable = this.schema + "." + tableKey;
                    correctJoinFormaTable = formatJoinTable.quotedTableName().qualifiedName;
                    let attributHanler = this.json[tableKey]!==undefined?this.json[tableKey].attribute_handlers:""// this.jsonCorrectTableColumnDescription.addAllColumn[correctJoinFormaTable]
                    
                    if (jsonAdqlContent.constraint[correctJoinFormaTable] !== undefined){
                        if (jsonAdqlContent.allCondition[correctJoinFormaTable]!= undefined){
                            correctWhereClose = api.tapServiceConnector.jsonAdqlContent.allCondition[correctJoinFormaTable];
                        }
                    }

                    this.objectMapWithAllDescription.tables[tableKey] = {
                        "description": jsonWithaoutDescription[tableKey].description,
                        "constraints": "",
                        "columns": attributHanler != undefined ? attributHanler : [],
                    }

                    if (jsonAdqlContent.constraint[correctJoinFormaTable] !== undefined) {
                        correctCondition = replaceAll(" WHERE " + correctWhereClose, "WHERE  AND ", "")
                        correctCondition = correctCondition.replaceAll("WHERE", " ");
                        this.objectMapWithAllDescription.tables[tableKey].constraints =  correctWhereClose != undefined ? correctCondition.trim() : "";
                    }

                } else {
                }

            }

        }
        this.objectMapWithAllDescription.map = map
        return this.objectMapWithAllDescription;
    }

    /**
     * In order to create the json with all join table
     * @param data :json the return json file of createJson()
     * @param root :the main table: root table
     * @return the json with all join table
     */
    TapServiceConnector.prototype.getObjectMapAndConstraint = function (data, root) {
        var reJson = {};
        for (var key in data) {
            var list_exist = [];
            list_exist.push(key);
            var joinJson = {};
            if (root == key) {
                var joinJsonJoin = {};
                for (var join in data[key].join_tables) {
                    var joinJsonJoin1 = {};
                    list_exist.push(join);
                    joinJsonJoin1["from"] = data[key].join_tables[join].from;
                    joinJsonJoin1["target"] = data[key].join_tables[join].target;
                    var a = this.verifiedJoin(data, list_exist, join);
                    if (JSON.stringify(a) != '{}') {
                        joinJsonJoin1["join_tables"] = a;
                        // console.log(a);
                    }
                    joinJsonJoin[join] = joinJsonJoin1;
                    joinJson["join_tables"] = joinJsonJoin;
                }
                reJson[key] = joinJson;
                break;
            }
        }
        return reJson;
    };

    /***
     * @param data: the main json
     * @param list_exist:list of tables who are already recorded
     * @param root: the root table
     */
    TapServiceConnector.prototype.verifiedJoin = function (data, list_exist, root) {
        var joinJsonJoin = {};
        for (var key in data) {
            if (key == root) {
                for (var join in data[key].join_tables) {
                    if (list_exist.indexOf(join) == -1) {
                        list_exist.push(join);
                        var joinJsonJoin1 = {};
                        joinJsonJoin1["from"] = data[key].join_tables[join].from;
                        joinJsonJoin1["target"] = data[key].join_tables[join].target;
                        var a = this.verifiedJoin(data, list_exist, join);
                        if (JSON.stringify(a) != '{}') {
                            joinJsonJoin1["join_tables"] = a;
                        }
                        joinJsonJoin[join] = joinJsonJoin1;
                    }
                }
                break;
            }
        }
        return joinJsonJoin;
    };

    TapServiceConnector.prototype.Query = function(adql){

        return this.tapService.Query(adql)
    }

    TapServiceConnector.prototype.createAllJoinTable = function (map){
        let table = []
        Object.keys(map).forEach(function (k) {
            let json = map[k];
            Object.keys(json.join_tables).forEach(function (k2) {
                table.push(k2);
                let json2 = json.join_tables[k2]
                if (json2.join_tables !== undefined) {
                    for (let f in json2.join_tables) {
                        table.push(f);
                        for (let c in json2.join_tables[f]) {
                            let json3 = json2.join_tables[f].join_tables
                            if (json3 !== undefined) {;
                                for (let c1 in json3) {
                                    table.push(c1);
                                }
                            }
                        }
                    }
                }

            })
            table= Array.from(new Set(table));
        })
        return table;
    }

    TapServiceConnector.prototype.getAdqlAndConstraint = function (table,constraint){
        let api = this.api;
        return this.tapService.createSimpleAdqlWithConstraint(table,constraint,api);
    }

    TapServiceConnector.prototype.replaceWhereAnd = function (jsonAdqlContent){
        const COUNT = 10;
        let space=" "
        for (let i=0;i<COUNT;i++){
            jsonAdqlContent = replaceAll(jsonAdqlContent, "WHERE"+space+"AND", " WHERE ");
            jsonAdqlContent = replaceAll(jsonAdqlContent,"AND"+space+"AND"," AND ");
            space+=" ";
        }
        if(jsonAdqlContent.indexOf("WHERE")===-1 && jsonAdqlContent.indexOf("AND") !==-1){
            jsonAdqlContent =replaceAll(jsonAdqlContent,"AND","WHERE");
        }
        return jsonAdqlContent;
    }

    /**
     * 
     * @param {*} query a valid adql query to be stored in the jsoonAdqlContent object
     */
    TapServiceConnector.prototype.setRootQuery =function(query){
        this.jsonAdqlContent.rootQuery = query;
    }

    /**
     * This method return (or create if the object was not existing yet) the jsonAdqlContent object which correspond to the following structure :
     * {'rootQuery': "", "constraint": {}, 'allJoin': {}, 'allCondition': {}, "status": {"status": "", 'orderErros': ""}}
     * where rootQuery store the query setted by the {@link setRootQuery}, constraint stores all the possible joint adql code for the current selected root table with all others table.
     * The allCondition field store all the requested conditions, allJoin store all the needed joints to fullfill those conditions.
     * The status field store status related data.
     * @returns {*} The jsonAdqlContent object
     */
    TapServiceConnector.prototype.getJsonAdqlContent = function(){
        if (this.jsonAdqlContent.status.status === "Not Built"){

            /*/ JsonAdqlContent building /*/

            let textJoinConstraint = "";
            let objectMap = this.getObjectMapAndConstraints();
            let map = objectMap.map;

            let schema = this.connector.service["schema"];
            schema = schema.quotedTableName().qualifiedName;

            for(let rootTable in map){ 

                let formatTableName = schema + "." + rootTable;
                let correctTableNameFormat = formatTableName.quotedTableName().qualifiedName;

                for (let key in map[rootTable].join_tables) {

                    let formatJoinTable = schema + "." + key;
                    let correctJoinFormaTable = formatJoinTable.quotedTableName().qualifiedName

                    textJoinConstraint = " JOIN  " + correctJoinFormaTable + " ";
                    textJoinConstraint += "ON " + correctTableNameFormat + "." + map[rootTable].join_tables[key].target;
                    textJoinConstraint += "=" + correctJoinFormaTable + "." + map[rootTable].join_tables[key].from;
                    this.jsonAdqlContent.constraint[correctJoinFormaTable] = textJoinConstraint
                    textJoinConstraint = "";
                    let json2 = map[rootTable].join_tables[key]
                    if (json2.join_tables !== undefined) {
                        for (let f in json2.join_tables) {
                            let firstJoin = this.jsonAdqlContent.constraint[correctJoinFormaTable]
                            let secondformatJoinTable = schema + "." + f;
                            let secondcorrectJoinFormaTable = secondformatJoinTable.quotedTableName().qualifiedName
                            textJoinConstraint = " JOIN  " + secondformatJoinTable + " ";
                            textJoinConstraint += "ON " + correctJoinFormaTable + "." + json2.join_tables[f].target;
                            textJoinConstraint += "=" + secondformatJoinTable + "." + json2.join_tables[f].from;
                            this.jsonAdqlContent.constraint[secondformatJoinTable] = firstJoin + " " + textJoinConstraint
                            for (let c in json2.join_tables[f]) {
                                let json3 = json2.join_tables[f].join_tables
                                if (json3 !== undefined) {
                                    for (let c1 in json3) {
                                        let secondJoin = this.jsonAdqlContent.constraint[secondformatJoinTable]
                                        let thirdformatJoinTable = schema + "." + c1;
                                        textJoinConstraint = " JOIN  " + thirdformatJoinTable + " ";
                                        textJoinConstraint += "ON " + secondcorrectJoinFormaTable + "." + json3[c1].target;
                                        textJoinConstraint += "=" + thirdformatJoinTable + "." + json3[c1].from;
                                        this.jsonAdqlContent.constraint[thirdformatJoinTable] = secondJoin + " " + textJoinConstraint
                                    }
                                }
                            }
                        }
                    }
                }
            }
            this.jsonAdqlContent.status.status = "Built";
        }
        return this.jsonAdqlContent;
    }

    return TapServiceConnector;
}());

function replaceAll(str, find, replace) {
    var escapedFind = find.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
    return str.replace(new RegExp(escapedFind, 'g'), replace);
}
